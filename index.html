<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NeuroMap Atlas — Map Your Mind</title>
  <meta name="description" content="A free, fully interactive brain‑mapping microsite: explore Emotion, Memory, Attention, Creativity, and Decision‑Making with 2‑minute practices." />
  <meta name="theme-color" content="#0b1020" />
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1731;
      --ink:#e8edf7;
      --muted:#a6b2d6;
      --teal:#2ad0ca;
      --gold:#f5d06f;
      --violet:#7aa2ff;
      --danger:#ff6b6b;
      --ok:#46e18a;
      --glass:rgba(255,255,255,0.06);
      /* networks palette */
      --exec:#2ad0ca;
      --salience:#ff9bd1;
      --default:#7aa2ff;
      --lang:#66d9ff;
      --sensor:#46e18a;
      --visual:#9ab6ff;
      --auditory:#ffd166;
    }
    html,body{height:100%}
    *{box-sizing:border-box}
    body{
      margin:0;
      background:radial-gradient(1200px 800px at 75% -10%, #101a3a 10%, transparent 60%),
                 radial-gradient(1000px 600px at -10% 20%, #0e1733 0%, transparent 55%),
                 var(--bg);
      color:var(--ink);
      font:16px/1.5 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial, sans-serif;
      overflow-x:hidden;
    }
    a{color:var(--teal); text-decoration:none}
    a:hover{text-decoration:underline}

    /* Layered hero */
    .hero{position:relative; min-height:92vh; display:grid; place-items:center; overflow:hidden}
    .layers{position:absolute; inset:0; pointer-events:none}
    .layer{position:absolute; inset:0}
    .glow{filter:blur(80px); opacity:.5}
    .glow.teal{background:radial-gradient(600px 600px at 20% 30%, rgba(42,208,202,.6), transparent 60%)}
    .glow.violet{background:radial-gradient(700px 700px at 80% 20%, rgba(122,162,255,.5), transparent 60%)}
    .glow.gold{background:radial-gradient(500px 500px at 50% 90%, rgba(245,208,111,.35), transparent 60%)}

    /* Canvas network sits behind */
    #net{position:absolute; inset:0; z-index:0}

    .hero-inner{position:relative; z-index:1; display:grid; gap:20px; padding:48px 24px; text-align:center; max-width:1100px}
    .kicker{letter-spacing:.12em; text-transform:uppercase; color:var(--muted)}
    h1{font-size:clamp(2.2rem, 2.6rem + 1.5vw, 4.2rem); line-height:1.05; margin:6px 0 10px}
    .sub{color:var(--muted); font-size:clamp(1rem, .9rem + .4vw, 1.2rem)}

    .cta-row{display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:10px}
    .btn{--bgc:var(--teal); --fg:#041016; display:inline-flex; align-items:center; gap:10px; padding:12px 18px; border-radius:14px; font-weight:600; background:var(--bgc); color:var(--fg); border:1px solid transparent; box-shadow:0 4px 18px rgba(42,208,202,.25); cursor:pointer; transition:transform .2s ease, box-shadow .2s ease}
    .btn.secondary{--bgc:transparent; --fg:var(--ink); border-color:rgba(122,162,255,.2); box-shadow:inset 0 0 0 1px rgba(122,162,255,.2)}
    .btn:focus{outline:2px solid var(--gold); outline-offset:2px}
    .btn.magnet-hover{transform:translate(var(--tx,0), var(--ty,0)); box-shadow:0 10px 24px rgba(42,208,202,.26)}

    /* Sticky nav */
    .nav{position:sticky; top:0; z-index:50; backdrop-filter:blur(12px); background:linear-gradient(180deg, rgba(10,14,30,.6), rgba(10,14,30,.25)); border-bottom:1px solid rgba(122,162,255,.15); display:flex; justify-content:center}
    .nav-inner{max-width:1100px; flex:1; padding:10px 16px; display:flex; gap:14px; align-items:center}
    .brand{font-weight:800; letter-spacing:.02em; display:flex; align-items:center; gap:6px}
    .spacer{flex:1}
    .nav a{padding:8px 12px; border-radius:10px}
    .nav a:hover{background:rgba(255,255,255,.06)}

    /* Logo + inputs */
    .logo{display:inline-grid; place-items:center; width:26px; height:26px; border-radius:8px; background:linear-gradient(135deg, rgba(42,208,202,.25), rgba(122,162,255,.25)); color:var(--ink); box-shadow:0 2px 10px rgba(0,0,0,.3)}
    .logo svg{display:block}
    .field{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .field input[type=email]{flex:1; min-width:220px; padding:12px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.06); color:var(--ink)}
    .field select{padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); color:var(--ink)}
    .hint{color:var(--muted); font-size:.95rem}

    /* Sections */
    section{padding:72px 20px}
    .wrap{max-width:1100px; margin:0 auto}

    /* Map grid */
    .map-grid{display:grid; grid-template-columns:1.05fr .95fr; gap:26px; align-items:center}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.14); border-radius:18px; padding:18px; box-shadow:0 20px 60px rgba(0,0,0,.3); backdrop-filter:blur(10px); position:relative}

    .brainbox{position:relative; aspect-ratio:4/3; border-radius:18px; overflow:hidden; transform:perspective(900px) rotateX(var(--rx,0)) rotateY(var(--ry,0)); transition:transform .2s ease}
    .brainbox svg{position:absolute; inset:0; width:100%; height:100%}
    .brainbox canvas{position:absolute; inset:0; width:100%; height:100%; pointer-events:none; mix-blend-mode:screen; opacity:.75}
    .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px}
    .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:var(--glass)}
    .dot{width:10px; height:10px; border-radius:50%}
    .zoomHUD{position:absolute; right:10px; bottom:10px; display:flex; gap:6px; z-index:2}
    .zoomHUD .btn{padding:8px 10px; font-weight:700}
    .zoomHUD .btn.secondary{--bgc:rgba(255,255,255,.08); --fg:var(--ink)}

    .panel h3{margin:.3rem 0}
    .panel p{color:var(--muted)}
    .panel .actions{display:flex; gap:10px; margin-top:6px; flex-wrap:wrap}
    .legend-block{display:grid; gap:6px; margin-top:12px}
    .legend-block label{display:flex; align-items:center; gap:8px}

    /* Node styles */
    .node .dot{stroke:rgba(255,255,255,.6); stroke-width:1.5; fill:var(--glass); opacity:.95; transition:opacity .2s ease, filter .2s ease}
    .node text{font-size:12px; fill:var(--ink); opacity:.9; text-shadow:0 1px 2px rgba(0,0,0,.5)}
    .node.active .dot{filter:drop-shadow(0 0 6px rgba(245,208,111,.6)); opacity:1}
    .node:hover .dot{opacity:1}
    .pathline{fill:none; stroke:var(--teal); stroke-width:2.5; stroke-linecap:round; stroke-linejoin:round; stroke-dasharray:6 10; animation:dash 2.4s linear infinite}
    @keyframes dash{to{stroke-dashoffset:-200}}

    .pulse{position:fixed; width:140px; height:140px; margin:-70px 0 0 -70px; border-radius:50%; border:2px solid rgba(245,208,111,.45); pointer-events:none; animation:pulse 1s ease-out forwards}
    @keyframes pulse{from{opacity:.6; transform:scale(.2);} to{opacity:0; transform:scale(1.4);}}

    .reveal{opacity:0; transform:translateY(24px); transition:opacity .6s ease, transform .6s ease}
    .reveal.show{opacity:1; transform:translateY(0)}

    #cursorOrb{position:fixed; width:240px; height:240px; top:0; left:0; pointer-events:none; mix-blend-mode:screen; background:radial-gradient(circle, rgba(122,162,255,.28) 0%, rgba(42,208,202,.05) 55%, transparent 70%); border-radius:50%; opacity:0; transition:opacity .4s ease}
    body.interacting #cursorOrb{opacity:1}

    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}

    dialog::backdrop{background:rgba(7,12,26,.6)}

    /* Region styles */
    .region{cursor:pointer; outline:none}
    .region:focus{filter:drop-shadow(0 0 0.7rem rgba(245,208,111,.6))}
    .region .fill{opacity:.18; transition:opacity .2s ease}
    .region:hover .fill{opacity:.28}
    .region.active .fill{opacity:.45}
    .region#emotion .fill{fill:var(--danger)}
    .region#memory .fill{fill:var(--gold)}
    .region#attention .fill{fill:var(--teal)}
    .region#creativity .fill{fill:var(--violet)}
    .region#decision .fill{fill:#9cff94}
    .region#language .fill{fill:#66d9ff}
    .region#social .fill{fill:#ff9bd1}
    .region#motivation .fill{fill:#ffa85c}

    /* Lobes + tooltip */
    .hidden{display:none}
    .lobe{fill:rgba(122,162,255,.12); stroke:rgba(255,255,255,.12)}
    .lobe.frontal{fill:rgba(122,162,255,.10)}
    .lobe.parietal{fill:rgba(42,208,202,.10)}
    .lobe.temporal{fill:rgba(255,209,102,.10)}
    .lobe.occipital{fill:rgba(154,182,255,.12)}
    #tip{position:fixed; z-index:5; pointer-events:none; padding:10px 12px; border-radius:10px; background:rgba(10,14,30,.85); border:1px solid rgba(255,255,255,.12); color:var(--ink); font-size:.95rem; box-shadow:0 10px 30px rgba(0,0,0,.4)}

    /* Self-scan */
    .scan{display:grid; gap:12px}
    .row{display:grid; grid-template-columns:110px 1fr 48px; gap:12px; align-items:center}
    input[type=range]{width:100%}
    .score{font-variant-numeric:tabular-nums; text-align:right; color:var(--muted)}
    .sparkWrap{margin-top:14px; display:flex; align-items:center; gap:12px}
    #sparkline{width:220px; height:60px; background:rgba(255,255,255,.04); border-radius:10px}
    .sparkLabel{color:var(--muted); font-size:.9rem}

    /* Stories */
    .grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(260px,1fr)); gap:16px}
    .story{padding:16px; border-radius:16px; background:var(--glass); border:1px solid rgba(255,255,255,.12)}
    .story h4{margin:.2rem 0}
    .story p{color:var(--muted)}

    /* Footer */
    footer{padding:40px 20px; color:var(--muted); text-align:center}

    @media (prefers-reduced-motion: reduce){
      .glow{display:none}
      [data-parallax]{transform:none !important}
      .btn, .brainbox{transition:none}
      .pathline{animation:none}
    }
    @media (max-width: 900px){
      .map-grid{grid-template-columns:1fr}
      .row{grid-template-columns:1fr 1fr; grid-template-areas:"label label" "range score"}
      .row label{grid-area:label}
      .row input{grid-area:range}
      .row .score{grid-area:score}
      .zoomHUD{position:static; justify-content:flex-end; margin-top:12px}
    }
    /* Phone-first UI */
    .mobileDock{
      position:fixed; left:0; right:0; bottom:0;
      padding:10px 12px calc(10px + env(safe-area-inset-bottom));
      display:none; gap:8px; justify-content:space-between;
      background:linear-gradient(180deg, rgba(10,14,30,.2), rgba(10,14,30,.75));
      backdrop-filter:blur(10px);
      border-top:1px solid rgba(255,255,255,.12);
      z-index:70;
    }
    .mobileDock .btn{ flex:1; text-align:center }

    @media (max-width: 720px){
      .hero{min-height:78vh}
      .hero-inner{padding:40px 16px}
      .btn{padding:14px 16px; border-radius:16px}
      .row{grid-template-columns:90px 1fr 40px}
      .brainbox{aspect-ratio:1/1}
      .legend{justify-content:center}
      .nav{position:static}
      .mobileDock{display:flex}
    }

    /* Hide cursor orb on touch devices */
    @media (hover: none) and (pointer: coarse){
      #cursorOrb{display:none}
    }
  </style>
</head>
<body>
  <!-- Sticky Nav -->
  <nav class="nav" aria-label="Primary">
    <div class="nav-inner">
      <div class="brand"><span class="logo" aria-hidden="true"><svg viewBox="0 0 64 64" width="24" height="24" role="img" aria-label="NeuroMap logo"><defs><linearGradient id="g1" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" style="stop-color:var(--teal)"/><stop offset="100%" style="stop-color:var(--violet)"/></linearGradient></defs><rect x="8" y="8" width="48" height="48" rx="11" ry="11" fill="rgba(255,255,255,.08)" stroke="rgba(255,255,255,.18)"/><path d="M22 42 V22 L42 42 V22" fill="none" stroke="url(#g1)" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/></svg></span> NeuroMap Atlas</div>
      <div class="spacer"></div>
      <a href="#map">Brain Map</a>
      <a href="#scan">Self-Scan</a>
      <a href="#stories">Stories</a>
      <a href="#subscribe">Subscribe</a>
      <a href="#contact">Contact</a>
    </div>
  </nav>
  <div id="cursorOrb" aria-hidden="true"></div>
  <div id="tip" role="tooltip" hidden></div>

  <!-- HERO -->
  <header class="hero" role="banner">
    <canvas id="net" aria-hidden="true"></canvas>
    <div class="layers">
      <div class="layer glow teal" data-parallax data-speed="0.06"></div>
      <div class="layer glow violet" data-parallax data-speed="0.09"></div>
      <div class="layer glow gold" data-parallax data-speed="0.03"></div>
    </div>
    <div class="hero-inner">
      <div class="kicker">Visually layered • Fully interactive • Free on GitHub Pages</div>
      <h1 data-parallax data-speed="-0.04">Map Your Mind. See Patterns. Change Behavior.</h1>
      <p class="sub" data-parallax data-speed="-0.02">Explore five core systems—Emotion, Memory, Attention, Creativity, Decision‑Making—with plain‑language visuals and 2‑minute practices.</p>
      <div class="cta-row">
        <button class="btn" id="startTour">Start a Guided Tour</button>
        <a class="btn secondary" href="#map">Explore the Map</a>
      </div>
    </div>
  </header>

  <!-- MAP SECTION -->
  <section id="map" aria-labelledby="map-title">
    <div class="wrap map-grid">
      <div class="card brainbox" aria-describedby="map-desc">
        <canvas id="neuronsCanvas" aria-hidden="true"></canvas>
        <svg viewBox="0 0 800 600" role="img" aria-labelledby="map-title map-desc">
          <title id="map-title">Interactive Brain Map</title>
          <desc id="map-desc">Schematic left‑hemisphere lateral view. Click a node to learn its role and try a 2‑minute practice. Not medical advice.</desc>
          <defs>
            <radialGradient id="bgGrad" cx="50%" cy="50%" r="70%">
              <stop offset="0%" stop-color="#ffffff" stop-opacity="0.06"/>
              <stop offset="100%" stop-color="#ffffff" stop-opacity="0.01"/>
            </radialGradient>
          </defs>
          <g id="brain">
            <path id="brainSilhouette" d="M210,210 C245,140 360,120 470,160 C560,195 610,260 595,330 C580,395 520,430 470,440 C430,448 385,448 335,438 C285,428 245,405 225,370 C205,335 198,298 207,260 C212,238 198,235 210,210 Z" fill="url(#bgGrad)" stroke="rgba(255,255,255,.18)" stroke-width="2"/>
            <ellipse cx="560" cy="410" rx="70" ry="48" fill="rgba(255,255,255,.03)" stroke="rgba(255,255,255,.18)"/>
          </g>
          <g id="lobes" class="hidden">
            <path id="lobe-frontal" class="lobe frontal" d="M235,165 L350,165 L335,240 L240,250 Z"/>
            <path id="lobe-parietal" class="lobe parietal" d="M350,165 L500,185 L470,235 L335,240 Z"/>
            <path id="lobe-temporal" class="lobe temporal" d="M330,260 L520,300 L520,390 L340,350 Z"/>
            <path id="lobe-occipital" class="lobe occipital" d="M500,185 L595,230 L575,320 L480,260 Z"/>
          </g>
          <g id="regions">
            <g id="emotion" class="region" tabindex="0" role="button" aria-label="Emotion">
              <circle class="fill" cx="275" cy="335" r="70"/>
              <circle cx="275" cy="335" r="74" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
            <g id="memory" class="region" tabindex="0" role="button" aria-label="Memory">
              <circle class="fill" cx="360" cy="370" r="58"/>
              <circle cx="360" cy="370" r="62" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
            <g id="attention" class="region" tabindex="0" role="button" aria-label="Attention">
              <circle class="fill" cx="460" cy="250" r="80"/>
              <circle cx="460" cy="250" r="84" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
            <g id="creativity" class="region" tabindex="0" role="button" aria-label="Creativity">
              <circle class="fill" cx="360" cy="210" r="60"/>
              <circle cx="360" cy="210" r="64" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
            <g id="decision" class="region" tabindex="0" role="button" aria-label="Decision-Making">
              <circle class="fill" cx="540" cy="325" r="65"/>
              <circle cx="540" cy="325" r="69" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
            <g id="language" class="region" tabindex="0" role="button" aria-label="Language">
              <circle class="fill" cx="235" cy="225" r="55"/>
              <circle cx="235" cy="225" r="59" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
            <g id="social" class="region" tabindex="0" role="button" aria-label="Social">
              <circle class="fill" cx="605" cy="235" r="58"/>
              <circle cx="605" cy="235" r="62" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
            <g id="motivation" class="region" tabindex="0" role="button" aria-label="Motivation">
              <circle class="fill" cx="470" cy="400" r="52"/>
              <circle cx="470" cy="400" r="56" fill="none" stroke="rgba(255,255,255,.18)" />
            </g>
          </g>
          <g id="pathLayer"></g>
          <g id="nodes"></g>
        </svg>
        <div class="legend" aria-hidden="true">
          <span class="pill"><span class="dot" style="background:var(--danger)"></span>Emotion</span>
          <span class="pill"><span class="dot" style="background:var(--gold)"></span>Memory</span>
          <span class="pill"><span class="dot" style="background:var(--teal)"></span>Attention</span>
          <span class="pill"><span class="dot" style="background:var(--violet)"></span>Creativity</span>
          <span class="pill"><span class="dot" style="background:#9cff94"></span>Decision</span>
          <span class="pill"><span class="dot" style="background:#66d9ff"></span>Language</span>
          <span class="pill"><span class="dot" style="background:#ff9bd1"></span>Social</span>
          <span class="pill"><span class="dot" style="background:#ffa85c"></span>Motivation</span>
        </div>
        <div class="zoomHUD" aria-hidden="false">
          <button class="btn secondary" id="zoomOut" type="button">−</button>
          <button class="btn secondary" id="zoomReset" type="button">1×</button>
          <button class="btn secondary" id="zoomIn" type="button">+</button>
        </div>
      </div>

      <aside class="card panel" aria-live="polite">
        <h3 id="panelTitle">Pick a node</h3>
        <p id="panelDesc">Click a labeled node to read what it does. Switch modes to view networks or feelings → pathways.</p>
        <div class="actions">
          <button class="btn" id="tryPractice" disabled>Do 2‑Minute Practice</button>
          <button class="btn secondary" id="focusRegion" disabled>Highlight</button>
          <button class="btn secondary" id="showEvidence" disabled>Evidence</button>
        </div>
        <div class="field" style="margin-top:12px">
          <label for="mode">Mode</label>
          <select id="mode">
            <option value="anatomy">Anatomy</option>
            <option value="networks">Networks</option>
            <option value="feeling">Feeling → Pathway</option>
          </select>
          <select id="feeling" disabled>
            <option value="">Choose feeling</option>
            <option value="stress">Stress</option>
            <option value="anxiety">Anxiety</option>
            <option value="sadness">Sadness</option>
            <option value="focus">Focus</option>
            <option value="creativity">Creative Flow</option>
          </select>
        </div>
        <div class="legend-block" aria-label="Network filter">
          <strong>Networks</strong>
          <label><input type="checkbox" id="netExec" checked> Executive Control</label>
          <label><input type="checkbox" id="netSalience" checked> Salience</label>
          <label><input type="checkbox" id="netDefault" checked> Default Mode</label>
          <label><input type="checkbox" id="netLang" checked> Language</label>
          <label><input type="checkbox" id="netSensor" checked> Sensorimotor</label>
          <label><input type="checkbox" id="netVisual" checked> Visual</label>
          <label><input type="checkbox" id="netAuditory" checked> Auditory</label>
        </div>
        <div class="field" style="margin-top:10px">
          <label><input type="checkbox" id="toggleLobes"> Show lobe overlays</label>
          <label style="margin-left:10px">Hemisphere
            <select id="hemi" style="margin-left:6px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); color:var(--ink)">
              <option value="L">Left</option>
              <option value="R">Right</option>
            </select>
          </label>
        </div>
      </aside>
    </div>
  </section>

  <!-- SELF SCAN -->
  <section id="scan" aria-labelledby="scan-title">
    <div class="wrap card reveal">
      <h2 id="scan-title">2‑Minute Self‑Scan</h2>
      <p class="sub">Slide to rate how you feel right now. We’ll highlight the system to focus on and suggest a micro‑practice.</p>
      <div class="scan" role="form" aria-describedby="scan-help">
        <div id="scan-help" class="sr-only"></div>
        <div class="row"><label for="mood">Emotion</label><input id="mood" type="range" min="0" max="10" step="1" value="5"/><div class="score" id="moodScore">5</div></div>
        <div class="row"><label for="mem">Memory</label><input id="mem" type="range" min="0" max="10" step="1" value="5"/><div class="score" id="memScore">5</div></div>
        <div class="row"><label for="focus">Attention</label><input id="focus" type="range" min="0" max="10" step="1" value="5"/><div class="score" id="focusScore">5</div></div>
        <div class="row"><label for="stress">Stress</label><input id="stress" type="range" min="0" max="10" step="1" value="5"/><div class="score" id="stressScore">5</div></div>
        <div class="row"><label for="create">Creativity</label><input id="create" type="range" min="0" max="10" step="1" value="5"/><div class="score" id="createScore">5</div></div>
      </div>
      <div class="cta-row" style="justify-content:flex-start; margin-top:10px">
        <button class="btn" id="analyze">Analyze & Highlight</button>
        <button class="btn secondary" id="downloadScan">Download Self-Scan</button>
        <button class="btn secondary" id="shareState">Share this state</button>
        <a class="btn secondary" href="#map">Back to Map</a>
      </div>
      <p id="scanResult" style="margin-top:8px; color:var(--muted)"></p>
      <div class="sparkWrap">
        <canvas id="sparkline" width="220" height="60"></canvas>
        <div class="sparkLabel" id="sparkLabel">No history yet</div>
      </div>
    </div>
  </section>

  <!-- STORIES -->
  <section id="stories" aria-labelledby="stories-title">
    <div class="wrap">
      <h2 id="stories-title" class="reveal">Stories & Insights</h2>
      <div class="grid">
        <article class="story reveal">
          <h4>Why micro‑practices beat willpower</h4>
          <p>Two minutes is enough to change the loop your brain is in—because state shift precedes belief change.</p>
        </article>
        <article class="story reveal">
          <h4>Attention as a trainable sense</h4>
          <p>A simple breath‑count drill improves sustained attention in under 120 seconds—try it before email.</p>
        </article>
        <article class="story reveal">
          <h4>Memory needs spacing</h4>
          <p>Most “forgetting” is timing, not talent. Spaced recall + zero‑pressure prompts keep knowledge alive.</p>
        </article>
      </div>
    </div>
  </section>

  <!-- CONTACT -->
  <section id="contact" aria-labelledby="contact-title">
    <div class="wrap card reveal">
      <h2 id="contact-title">Contact</h2>
      <p>Want to collaborate or contribute a practice? Email <a href="mailto:info@recursive-emergence.org">info@recursive-emergence.org</a>. This is a learning resource, not medical advice.</p>
    </div>
  </section>

  <!-- SUBSCRIBE -->
  <section id="subscribe" aria-labelledby="subscribe-title">
    <div class="wrap card reveal">
      <h2 id="subscribe-title">Subscribe for New Brain Maps</h2>
      <p class="hint">Free, occasional updates. No spam. Your email stays private.</p>
      <div class="field" role="form" aria-label="Subscribe form">
        <input id="subEmail" type="email" placeholder="info@recursive-emergence.org" required />
        <button class="btn" id="subBtn">Subscribe</button>
        <button class="btn secondary" id="subAlt">Just email me</button>
      </div>
      <p id="subMsg" class="hint" style="margin-top:8px"></p>
    </div>
  </section>

  <footer>
    <small>© <span id="year"></span> NeuroMap Atlas. Built as a single static file for free GitHub Pages hosting. No trackers. No external libraries.</small>
  </footer>

  <div class="mobileDock" aria-hidden="false">
    <a class="btn secondary" href="#map">Map</a>
    <a class="btn secondary" href="#scan">Self-Scan</a>
    <a class="btn secondary" href="#subscribe">Subscribe</a>
  </div>

  <!-- Modal (practice) -->
  <dialog id="practiceModal" style="border:none; border-radius:16px; padding:0; background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05)); color:var(--ink); max-width:640px; width:92%">
    <form method="dialog" style="padding:18px">
      <h3 id="practiceTitle">2‑Minute Practice</h3>
      <p id="practiceText" style="color:var(--muted)"></p>
      <div class="cta-row" style="justify-content:flex-end">
        <button class="btn secondary">Close</button>
      </div>
    </form>
  </dialog>

  <dialog id="evidenceModal" style="border:none; border-radius:16px; padding:0; background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05)); color:var(--ink); max-width:680px; width:92%">
    <form method="dialog" style="padding:20px; display:grid; gap:14px">
      <h3 id="evidenceTitle">Evidence</h3>
      <div id="evidenceBody" style="color:var(--muted); font-size:.95rem"></div>
      <div class="cta-row" style="justify-content:flex-end">
        <button class="btn secondary">Close</button>
      </div>
    </form>
  </dialog>

  <script>
    const $ = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

    // ===== YEAR =====
    $('#year').textContent = new Date().getFullYear();

    // ===== PARTICLE NETWORK BACKGROUND =====
    (function particleNet(){
      const c = document.getElementById('net');
      const ctx = c.getContext('2d');
      let w, h, dpr = Math.min(2, window.devicePixelRatio || 1);
      let points = [];
      function resize(){
        w = c.clientWidth; h = c.clientHeight;
        c.width = w*dpr; c.height = h*dpr;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        points = new Array(Math.max(40, Math.min(120, Math.round((w*h)/10000)))).fill().map(()=>({
          x: Math.random()*w, y: Math.random()*h,
          vx: (Math.random()-.5)*0.6, vy: (Math.random()-.5)*0.6,
          r: 1 + Math.random()*2
        }));
      }
      resize();
      window.addEventListener('resize', resize);
      function step(){
        ctx.clearRect(0,0,w,h);
        for(const p of points){
          p.x+=p.vx; p.y+=p.vy;
          if(p.x<0||p.x>w) p.vx*=-1; if(p.y<0||p.y>h) p.vy*=-1;
          ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
          ctx.fillStyle='rgba(122,162,255,.55)'; ctx.fill();
        }
        for(let i=0;i<points.length;i++){
          for(let j=i+1;j<points.length;j++){
            const a=points[i], b=points[j];
            const dx=a.x-b.x, dy=a.y-b.y; const dist=Math.hypot(dx,dy);
            if(dist<120){
              const alpha = .12*(1 - dist/120);
              ctx.strokeStyle = `rgba(42,208,202,${alpha})`;
              ctx.lineWidth = 1;
              ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
            }
          }
        }
        requestAnimationFrame(step);
      }
      const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      if(!mediaQuery.matches) step();
    })();

    // ===== PARALLAX =====
    (function parallax(){
      const els = $$('[data-parallax]');
      if(!els.length) return;
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)');
      if(reduce.matches) return;
      let targetY = 0, currentY = 0;
      const onScroll = ()=>{ targetY = window.scrollY || 0; };
      const raf = ()=>{
        currentY += (targetY - currentY) * 0.08;
        els.forEach(el=>{
          const speed = parseFloat(el.getAttribute('data-speed')||'0');
          el.style.transform = `translateY(${currentY*speed}px)`;
        });
        requestAnimationFrame(raf);
      };
      onScroll();
      document.addEventListener('scroll', onScroll, {passive:true});
      raf();
    })();

    // ===== REGIONS & PRACTICES =====
    const regions = {
      emotion: {
        title: 'Emotion',
        desc: 'Your body’s quick meaning-maker. Name it to tame it; breath shapes the signal.',
        practice: `Box Breath (2 min): Inhale 4 · Hold 4 · Exhale 4 · Hold 4 — repeat 8 cycles. As you exhale, softly label the feeling (e.g., “restless,” “tight,” “calm”).`
      },
      memory: {
        title: 'Memory',
        desc: 'Encoding and recall like rhythm—short, spaced repetitions keep knowledge alive.',
        practice: `Tiny Recall (2 min): Pick one fact you learned today. Write it from memory in 1 sentence. Wait 30s. Write it again with 10% more detail.`
      },
      attention: {
        title: 'Attention',
        desc: 'Sustained focus is trainable; brief drills sharpen the lens before tasks.',
        practice: `Breath‑Count (2 min): Count 1 to 10 with each exhale. If distracted, restart at 1 with zero judgment. Aim for one clean 1→10.`
      },
      creativity: {
        title: 'Creativity',
        desc: 'Divergent ideas emerge when pressure drops and associations widen.',
        practice: `Associative Burst (2 min): Pick an object near you. List 10 alternate uses in 120 seconds. Do not edit; go for volume.`
      },
      decision: {
        title: 'Decision-Making',
        desc: 'Clarity comes from comparing futures, not arguments. Make options visible.',
        practice: `Two-Futures Flip (2 min): Name Choice A vs B. For each, speak one sentence: “Six months from now, I will be…”. Pick the calmer body answer.`
      },
      language: {
        title: 'Language',
        desc: 'Words shape attention. Clear phrasing reduces cognitive load and improves recall.',
        practice: `Rename It (2 min): Take a complex idea you’re using today. Rewrite it in one short, concrete sentence a 10-year-old could follow.`
      },
      social: {
        title: 'Social',
        desc: 'Regulation is co-regulation. A calm voice and eye focus can shift your state in seconds.',
        practice: `30-Second Co-Reg (2 min): Call or voice-note a friend. Slow your voice, 6-second exhale. Name one appreciation.`
      },
      motivation: {
        title: 'Motivation',
        desc: 'Tiny starts beat big plans. Lower the bar and raise consistency.',
        practice: `Starter Step (2 min): Choose one task. Define a 60-second first move (open doc, title it). Do that now; then decide the next tile.`
      }
    };

    const atlas = {
      nodes: {
        dlPFC:{ x:300, y:180, label:'dlPFC', name:'Dorsolateral Prefrontal Cortex', networks:['Executive Control'], lobe:'Frontal', desc:'Working memory, planning, top-down control.', practiceKey:'decision', color:'var(--exec)' },
        mPFC:{ x:350, y:200, label:'mPFC', name:'Medial Prefrontal Cortex', networks:['Default Mode'], lobe:'Frontal', desc:'Self-referential thought, valuation.', practiceKey:'emotion', color:'var(--default)' },
        ACC:{ x:360, y:240, label:'ACC', name:'Anterior Cingulate', networks:['Executive Control','Salience'], lobe:'Cingulate', desc:'Conflict monitoring, error detection.', practiceKey:'attention', color:'var(--exec)' },
        Insula:{ x:420, y:300, label:'Insula', name:'Insula', networks:['Salience'], lobe:'Insular', desc:'Interoception, body-state awareness.', practiceKey:'emotion', color:'var(--salience)' },
        Amygdala:{ x:450, y:360, label:'Amygdala', name:'Amygdala', networks:['Salience'], lobe:'Medial Temporal', desc:'Rapid threat/emotion tagging.', practiceKey:'emotion', color:'var(--salience)' },
        Hippocampus:{ x:420, y:380, label:'Hipp', name:'Hippocampus', networks:['Default Mode'], lobe:'Medial Temporal', desc:'Encoding contexts, memory consolidation.', practiceKey:'memory', color:'var(--default)' },
        Thalamus:{ x:380, y:300, label:'Thal', name:'Thalamus', networks:['Salience','Executive Control'], lobe:'Subcortical', desc:'Sensory relay and gating.', practiceKey:'attention', color:'var(--salience)' },
        PCC:{ x:430, y:230, label:'PCC', name:'Posterior Cingulate', networks:['Default Mode'], lobe:'Cingulate', desc:'Context, autobiographical memory.', practiceKey:'creativity', color:'var(--default)' },
        V1:{ x:575, y:260, label:'V1', name:'Primary Visual (V1)', networks:['Visual'], lobe:'Occipital', desc:'Early visual processing.', practiceKey:'attention', color:'var(--visual)' },
        A1:{ x:480, y:300, label:'A1', name:'Primary Auditory (A1)', networks:['Auditory'], lobe:'Temporal', desc:'Sound features & timing.', practiceKey:'attention', color:'var(--auditory)' },
        Motor:{ x:360, y:170, label:'M1', name:'Primary Motor (M1)', networks:['Sensorimotor'], lobe:'Frontal', desc:'Voluntary movement output.', practiceKey:'motivation', color:'var(--sensor)' },
        Somatosensory:{ x:395, y:170, label:'S1', name:'Somatosensory (S1)', networks:['Sensorimotor'], lobe:'Parietal', desc:'Touch & body map.', practiceKey:'emotion', color:'var(--sensor)' },
        Broca:{ x:330, y:260, label:'Broca', name:'Broca’s Area', networks:['Language'], lobe:'Frontal (IFG)', desc:'Speech production, syntax planning.', practiceKey:'language', color:'var(--lang)' },
        Wernicke:{ x:480, y:240, label:'Wern', name:'Wernicke’s Area', networks:['Language'], lobe:'Temporal (STG/TPJ)', desc:'Language comprehension.', practiceKey:'language', color:'var(--lang)' },
        PPC:{ x:460, y:200, label:'PPC', name:'Posterior Parietal', networks:['Executive Control'], lobe:'Parietal', desc:'Attention re-orienting, spatial maps.', practiceKey:'attention', color:'var(--exec)' },
        Cerebellum:{ x:560, y:400, label:'Cereb', name:'Cerebellum', networks:['Sensorimotor'], lobe:'Cerebellar', desc:'Timing, error correction, automatization.', practiceKey:'motivation', color:'var(--sensor)' },
      },
      feelings: {
        stress: ['Amygdala','Insula','ACC','dlPFC'],
        anxiety: ['Amygdala','Hippocampus','mPFC','dlPFC'],
        sadness: ['mPFC','Amygdala','PCC','Hippocampus'],
        focus: ['dlPFC','ACC','Thalamus','PPC'],
        creativity: ['mPFC','PCC','Wernicke','V1']
      },
      networks: {
        'Executive Control': ['dlPFC','ACC','PPC'],
        'Salience': ['Insula','ACC','Amygdala','Thalamus'],
        'Default Mode': ['mPFC','PCC','Hippocampus'],
        'Language': ['Broca','Wernicke'],
        'Sensorimotor': ['Motor','Somatosensory','Cerebellum'],
        'Visual': ['V1'],
        'Auditory': ['A1']
      }
    };

    const categoryToNodes = {
      emotion:['Amygdala','Insula','mPFC','ACC'],
      memory:['Hippocampus','PCC','Thalamus'],
      attention:['dlPFC','ACC','PPC','Thalamus'],
      creativity:['mPFC','PCC','Wernicke','V1'],
      decision:['dlPFC','ACC','PPC'],
      language:['Broca','Wernicke'],
      social:['Insula','Amygdala','mPFC','ACC'],
      motivation:['dlPFC','Cerebellum','Motor']
    };

    const panelTitle = document.getElementById('panelTitle');
    const panelDesc = document.getElementById('panelDesc');
    const tryBtn = document.getElementById('tryPractice');
    const focusBtn = document.getElementById('focusRegion');
    const showEvBtn = document.getElementById('showEvidence');
    const modal = document.getElementById('practiceModal');
    const practiceTitle = document.getElementById('practiceTitle');
    const practiceText = document.getElementById('practiceText');
    const evidenceModal = document.getElementById('evidenceModal');
    const evidenceTitle = document.getElementById('evidenceTitle');
    const evidenceBody = document.getElementById('evidenceBody');
    const sparkLabel = document.getElementById('sparkLabel');

    const bib = {
      miller2001: { title:'An integrative theory of prefrontal cortex function', cite:'Miller & Cohen (2001) Annu. Rev. Neurosci.', link:'https://doi.org/10.1146/annurev.neuro.24.1.167' },
      menon2010: { title:'Large-scale brain networks and psychopathology', cite:'Menon (2011) Trends Cogn. Sci.', link:'https://doi.org/10.1016/j.tics.2011.08.003' },
      raichle2015: { title:'The brain’s default mode network', cite:'Raichle (2015) Annu. Rev. Neurosci.', link:'https://doi.org/10.1146/annurev-neuro-071013-014030' },
      damasio1994: { title:'Somatic marker hypothesis and decision-making', cite:'Damasio (1994) Descartes’ Error', link:'https://doi.org/10.1515/9781400820793' },
      price2012: { title:'The anatomy of language: a review of 100 fMRI studies', cite:'Price (2012) J. Anat.', link:'https://doi.org/10.1111/j.1469-7580.2012.01500.x' },
      schmahmann2019: { title:'The cerebellum and cognition', cite:'Schmahmann (2019) Neurosci. Lett.', link:'https://doi.org/10.1016/j.neulet.2018.07.005' }
    };

    let nodeRefs = {
      dlPFC:['miller2001'],
      ACC:['miller2001','menon2010'],
      Insula:['menon2010'],
      Amygdala:['menon2010'],
      Hippocampus:['raichle2015'],
      mPFC:['raichle2015'],
      PCC:['raichle2015'],
      Thalamus:['menon2010'],
      Broca:['price2012'],
      Wernicke:['price2012'],
      Cerebellum:['schmahmann2019'],
      Motor:['schmahmann2019']
    };

    let categoryRefs = {
      attention:['miller2001','menon2010'],
      emotion:['menon2010','damasio1994'],
      memory:['raichle2015'],
      creativity:['raichle2015'],
      decision:['damasio1994','miller2001'],
      language:['price2012'],
      motivation:['schmahmann2019'],
      social:['menon2010']
    };

    function openEvidence(keys, subject){
      if(!evidenceModal) return;
      const items = Array.isArray(keys) ? keys.filter(Boolean) : [];
      evidenceTitle.textContent = `Evidence: ${subject}`;
      if(!items.length){
        evidenceBody.innerHTML = '<p>No curated sources yet—check back soon.</p>';
      } else {
        const list = items.map(key=>{
          const entry = bib[key];
          if(!entry) return `<li>${key}</li>`;
          const link = entry.link ? `<a href="${entry.link}" target="_blank" rel="noreferrer">${entry.cite}</a>` : entry.cite;
          return `<li><strong>${entry.title}</strong><br>${link}</li>`;
        }).join('');
        evidenceBody.innerHTML = `<ol>${list}</ol>`;
      }
      evidenceModal.showModal();
    }

    let currentRegion = null;
    let currentNode = null;
    let currentHemisphere = 'L';

    const nodesLayer = document.getElementById('nodes');
    const pathLayer = document.getElementById('pathLayer');

    function rebuildNodes(){
      nodesLayer.innerHTML = '';
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      for(const [id, n] of Object.entries(atlas.nodes)){
        n.x0 = n.x; n.y0 = n.y;
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','node');
        g.setAttribute('data-id', id);
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('class','dot'); c.setAttribute('cx', n.x); c.setAttribute('cy', n.y);
        c.setAttribute('r', isCoarse? '10' : '6');
        c.setAttribute('fill', 'var(--glass)');
        c.setAttribute('stroke', n.color || 'var(--teal)');
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x', n.x + (isCoarse? 14 : 10));
        t.setAttribute('y', n.y + (isCoarse? 6 : 4));
        if(isCoarse) t.setAttribute('font-size','14');
        t.textContent = n.label || id;
        g.appendChild(c); g.appendChild(t); nodesLayer.appendChild(g);
      }
      $$('#nodes .node').forEach(el=>{
        el.addEventListener('click', ()=> selectNode(el.getAttribute('data-id')));
        el.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); selectNode(el.getAttribute('data-id')); } });
        el.setAttribute('tabindex','0'); el.setAttribute('role','button');
      });
      updateNetworkVisibility?.();
    }
    rebuildNodes();

    const modeSel = document.getElementById('mode');
    const feelingSel = document.getElementById('feeling');

    let activePathSequence = null;
    let activePath = null;
    let signalRAF = null;
    let signalCircle = null;
    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

    function stopSignal(){
      if(signalRAF){ cancelAnimationFrame(signalRAF); signalRAF=null; }
      if(signalCircle){ signalCircle.remove(); signalCircle=null; }
    }

    function startSignal(){
      if(reduceMotion.matches) return;
      const path = activePath;
      if(!path) return;
      stopSignal();
      const len = path.getTotalLength();
      signalCircle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      signalCircle.setAttribute('r','4');
      signalCircle.setAttribute('fill','var(--gold)');
      signalCircle.setAttribute('opacity','.9');
      pathLayer.appendChild(signalCircle);
      const duration = 2400;
      const start = performance.now();
      const step = (now)=>{
        const elapsed = (now - start) % duration;
        const u = elapsed / duration;
        const point = path.getPointAtLength(u * len);
        signalCircle.setAttribute('cx', point.x);
        signalCircle.setAttribute('cy', point.y);
        signalRAF = requestAnimationFrame(step);
      };
      signalRAF = requestAnimationFrame(step);
    }

    function drawPath(sequence){
      stopSignal();
      pathLayer.innerHTML='';
      $$('#nodes .node').forEach(node=> node.classList.remove('active'));
      if(!sequence || !sequence.length){
        activePathSequence = null;
        activePath = null;
        return;
      }
      const points = sequence.map(key => atlas.nodes[key]).filter(Boolean);
      if(!points.length) return;
      const d = points.map((p, i)=> `${i?'L':'M'}${p.x} ${p.y}`).join(' ');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', d);
      path.setAttribute('class','pathline');
      pathLayer.appendChild(path);
      $$('#nodes .node').forEach(node=>{
        const id = node.getAttribute('data-id');
        node.classList.toggle('active', sequence.includes(id));
      });
      activePathSequence = sequence.slice();
      activePath = path;
      startSignal();
    }

    function neutralNodes(){
      $$('#nodes .node .dot').forEach(el=>{
        const id = el.parentElement.getAttribute('data-id');
        el.setAttribute('stroke', atlas.nodes[id].color);
      });
      drawPath(null);
    }

    function colorByNetworks(){
      $$('#nodes .node .dot').forEach(el=>{
        const id = el.parentElement.getAttribute('data-id');
        const node = atlas.nodes[id];
        const net = node.networks[0] || 'Executive Control';
        const color = net==='Executive Control'? 'var(--exec)'
          : net==='Salience'? 'var(--salience)'
          : net==='Default Mode'? 'var(--default)'
          : net==='Language'? 'var(--lang)'
          : net==='Sensorimotor'? 'var(--sensor)'
          : net==='Visual'? 'var(--visual)'
          : net==='Auditory'? 'var(--auditory)'
          : 'var(--teal)';
        el.setAttribute('stroke', color);
      });
      drawPath(null);
    }

    function selectNode(id){
      currentNode = id;
      $$('#regions .region').forEach(el=>el.classList.remove('active'));
      $$('#nodes .node').forEach(g=>g.classList.toggle('active', g.getAttribute('data-id')===id));
      const n = atlas.nodes[id];
      panelTitle.textContent = n.name;
      panelDesc.textContent = `${n.desc} (${n.lobe}; networks: ${n.networks.join(', ')})`;
      tryBtn.disabled = false; focusBtn.disabled = false; pulseAtRegion('attention');
      drawPath([id]);
      setHotspots([id]);
      if(showEvBtn){
        const refs = nodeRefs[id] || [];
        showEvBtn.disabled = refs.length===0;
        showEvBtn.onclick = refs.length ? ()=> openEvidence(refs, n.name) : null;
      }
    }

    const regionCenters = {
      emotion:[275,335], memory:[360,370], attention:[460,250], creativity:[360,210], decision:[540,325],
      language:[235,225], social:[605,235], motivation:[470,400]
    };

    function regionPosition(id){
      const [x,y] = regionCenters[id] || [400,300];
      return currentHemisphere === 'R' ? [800 - x, y] : [x,y];
    }

    function pulseAtRegion(id){
      const svg = document.querySelector('.brainbox svg');
      if(!svg) return;
      const viewBox = svg.viewBox.baseVal;
      const rect = svg.getBoundingClientRect();
      const [cx, cy] = regionPosition(id);
      const x = rect.left + (cx / viewBox.width) * rect.width;
      const y = rect.top + (cy / viewBox.height) * rect.height;
      const pulse = document.createElement('div');
      pulse.className = 'pulse';
      pulse.style.left = `${x}px`;
      pulse.style.top = `${y}px`;
      document.body.appendChild(pulse);
      pulse.addEventListener('animationend', ()=> pulse.remove());
    }

    function selectRegion(id){
      currentRegion = id;
      $$('.region').forEach(g=>g.classList.toggle('active', g.id===id));
      const data = regions[id];
      panelTitle.textContent = data.title;
      panelDesc.textContent = `${data.desc}`;
      tryBtn.disabled = false; focusBtn.disabled = false;
      pulseAtRegion(id);
      highlightCategoryNodes(id);
    }

    $$('#regions .region').forEach(g=>{
      g.addEventListener('click', ()=> selectRegion(g.id));
      g.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); selectRegion(g.id);} });
    });

    tryBtn.addEventListener('click', ()=>{
      if(currentNode){
        const node = atlas.nodes[currentNode];
        const key = node.practiceKey || 'attention';
        practiceTitle.textContent = `${node.name}: 2‑Minute Practice`;
        practiceText.textContent = regions[key]?.practice || 'Breathe slow 6-second exhales for 2 minutes; label the sensation once per breath.';
        modal.showModal();
        return;
      }
      if(!currentRegion) return;
      practiceTitle.textContent = `${regions[currentRegion].title}: 2‑Minute Practice`;
      practiceText.textContent = regions[currentRegion].practice;
      modal.showModal();
    });

    focusBtn.addEventListener('click', ()=>{
      if(currentRegion){
        const el = document.getElementById(currentRegion);
        el?.scrollIntoView({behavior:'smooth', block:'center', inline:'center'});
        pulseAtRegion(currentRegion);
      } else if(currentNode){
        const nodeEl = document.querySelector(`#nodes .node[data-id="${currentNode}"] circle`);
        if(nodeEl){
          const rect = nodeEl.getBoundingClientRect();
          window.scrollTo({top: window.scrollY + rect.top - window.innerHeight/2, behavior:'smooth'});
        }
      }
    });

    modeSel.addEventListener('change', ()=>{
      const mode = modeSel.value;
      if(mode === 'feeling'){
        feelingSel.disabled = false;
        drawPath(null);
        panelTitle.textContent = 'Feeling → Pathway';
        panelDesc.textContent = 'Choose a feeling to visualize a typical brain pathway (schematic).';
        if(showEvBtn){ showEvBtn.disabled = true; showEvBtn.onclick = null; }
      } else {
        feelingSel.disabled = true;
        feelingSel.value = '';
        if(mode === 'networks'){
          colorByNetworks();
          panelTitle.textContent = 'Networks view';
          panelDesc.textContent = 'Nodes colored by major functional networks. Click to drill into details.';
        } else {
          neutralNodes();
          panelTitle.textContent = 'Anatomy view';
          panelDesc.textContent = 'Click a node to learn its role and see matching micro-practices.';
        }
        if(showEvBtn){ showEvBtn.disabled = true; showEvBtn.onclick = null; }
      }
    });

    feelingSel.addEventListener('change', ()=>{
      const key = feelingSel.value;
      if(!key) return;
      const sequence = atlas.feelings[key];
      drawPath(sequence);
      if(sequence && sequence.length){
        const first = sequence[0];
        currentNode = first;
        panelTitle.textContent = `${key.charAt(0).toUpperCase()}${key.slice(1)} pathway`;
        panelDesc.textContent = sequence.map(id=>atlas.nodes[id]?.name).filter(Boolean).join(' → ');
        tryBtn.disabled = false;
        focusBtn.disabled = false;
        setHotspots(sequence);
        if(showEvBtn){ showEvBtn.disabled = true; showEvBtn.onclick = null; }
      }
    });

    function highlightCategoryNodes(key){
      const list = categoryToNodes[key] || [];
      currentRegion = key;
      currentNode = null;
      $$('#regions .region').forEach(g=>g.classList.toggle('active', g.id===key));
      $$('#nodes .node').forEach(node=>node.classList.remove('active'));
      drawPath(list);
      setHotspots(list);
      tryBtn.disabled = false;
      focusBtn.disabled = false;
      if(showEvBtn){
        const refs = categoryRefs[key] || [];
        showEvBtn.disabled = refs.length===0;
        showEvBtn.onclick = refs.length ? ()=> openEvidence(refs, regions[key]?.title || key) : null;
      }
    }

    const tourOrder = ['emotion','memory','attention','creativity','decision','language','social','motivation'];
    document.getElementById('startTour').addEventListener('click', ()=>{
      let i = 0;
      selectRegion(tourOrder[i]);
      const id = setInterval(()=>{
        i += 1;
        if(i >= tourOrder.length){ clearInterval(id); return; }
        selectRegion(tourOrder[i]);
      }, 2200);
    });

    const sliders = [
      { id:'mood',  weight:{ emotion:+1, decision:-.2, social:+.5, motivation:+.3 } },
      { id:'mem',   weight:{ memory:+1, language:+.4 } },
      { id:'focus', weight:{ attention:+1, creativity:-.2, language:+.3 } },
      { id:'stress',weight:{ emotion:+.8, attention:-.3, decision:+.4, social:+.5 } },
      { id:'create',weight:{ creativity:+1, motivation:+.3 } },
    ];

    sliders.forEach(s=>{
      const el = document.getElementById(s.id);
      const out = document.getElementById(`${s.id}Score`);
      el.addEventListener('input', ()=>{ out.textContent = el.value; });
    });

    function analyze(){
      const scores = { emotion:0, memory:0, attention:0, creativity:0, decision:0, language:0, social:0, motivation:0 };
      sliders.forEach(s=>{
        const v = parseInt(document.getElementById(s.id).value,10);
        for(const key in s.weight){ scores[key] += v * s.weight[key]; }
      });
      const best = Object.entries(scores).sort((a,b)=>b[1]-a[1])[0][0];
      panelTitle.textContent = regions[best].title;
      panelDesc.textContent = regions[best].desc || 'Suggested focus based on your self-scan.';
      document.getElementById('scanResult').textContent = `Focus suggestion: ${regions[best].title}. Open the 2-minute practice.`;
      highlightCategoryNodes(best);
      pulseAtRegion(best);

      // save short history for sparkline
      const entry = {
        t: Date.now(),
        mood: +document.getElementById('mood').value,
        mem: +document.getElementById('mem').value,
        focus: +document.getElementById('focus').value,
        stress: +document.getElementById('stress').value,
        create: +document.getElementById('create').value,
        best
      };
      const hist = JSON.parse(localStorage.getItem('nm_history')||'[]');
      hist.push(entry); while(hist.length>50) hist.shift();
      localStorage.setItem('nm_history', JSON.stringify(hist));
      drawSpark();
      window.location.hash = '#map';
    }
    document.getElementById('analyze').addEventListener('click', analyze);

    function drawSpark(){
      const canvas = document.getElementById('sparkline');
      if(!canvas) return;
      const ctx = canvas.getContext('2d');
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const width = canvas.clientWidth || canvas.width;
      const height = canvas.clientHeight || canvas.height;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      const hist = JSON.parse(localStorage.getItem('nm_history')||'[]');
      ctx.clearRect(0,0,width,height);
      if(!hist.length){
        if(sparkLabel) sparkLabel.textContent = 'No history yet';
        return;
      }
      const keys = Object.keys(regions);
      const step = hist.length>1 ? width/(hist.length-1) : 0;
      ctx.strokeStyle = 'rgba(122,162,255,0.7)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      hist.forEach((item,i)=>{
        const idx = Math.max(0, keys.indexOf(item.best));
        const ratio = keys.length>1 ? idx/(keys.length-1) : 0.5;
        const x = i*step;
        const y = height - ratio*height;
        if(i===0){ ctx.moveTo(x,y); } else { ctx.lineTo(x,y); }
      });
      ctx.stroke();
      ctx.fillStyle = 'rgba(42,208,202,0.85)';
      hist.forEach((item,i)=>{
        const idx = Math.max(0, keys.indexOf(item.best));
        const ratio = keys.length>1 ? idx/(keys.length-1) : 0.5;
        const x = i*step;
        const y = height - ratio*height;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI*2);
        ctx.fill();
      });
      if(sparkLabel){
        const latest = hist[hist.length-1];
        sparkLabel.textContent = `Last focus: ${regions[latest.best]?.title || latest.best}`;
      }
    }
    drawSpark();

    const subEmail = document.getElementById('subEmail');
    const subBtn = document.getElementById('subBtn');
    const subAlt = document.getElementById('subAlt');
    const subMsg = document.getElementById('subMsg');

    function validEmail(value){
      return /.+@.+\..+/.test(value);
    }

    subBtn?.addEventListener('click', ()=>{
      const value = subEmail.value.trim();
      if(!validEmail(value)){ subMsg.textContent = 'Enter a valid email.'; return; }
      const subject = encodeURIComponent('Subscribe me to NeuroMap Atlas');
      const body = encodeURIComponent(`Please add me to updates.\nEmail: ${value}`);
      window.location.href = `mailto:info@recursive-emergence.org?subject=${subject}&body=${body}`;
      subMsg.textContent = 'Opening your email app… If nothing happens, click “Just email me.”';
    });

    subAlt?.addEventListener('click', ()=>{
      const value = subEmail.value.trim();
      const link = `mailto:info@recursive-emergence.org?subject=${encodeURIComponent('Subscribe me to NeuroMap Atlas')}&body=${encodeURIComponent('Please add me to updates. Email: ' + (value || '(type here)'))}`;
      window.location.href = link;
    });

    function getValues(){
      return {
        mood: parseInt(document.getElementById('mood').value,10),
        mem: parseInt(document.getElementById('mem').value,10),
        focus: parseInt(document.getElementById('focus').value,10),
        stress: parseInt(document.getElementById('stress').value,10),
        create: parseInt(document.getElementById('create').value,10),
      };
    }

    function computeBest(){
      const totals = { emotion:0, memory:0, attention:0, creativity:0, decision:0, language:0, social:0, motivation:0 };
      sliders.forEach(s=>{
        const v = parseInt(document.getElementById(s.id).value,10);
        for(const key in s.weight){ totals[key] += v * s.weight[key]; }
      });
      return Object.entries(totals).sort((a,b)=>b[1]-a[1])[0][0];
    }

    function timestamp(){
      const d = new Date();
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}-${pad(d.getMinutes())}`;
    }

    function download(name, text){
      const blob = new Blob([text], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }

    document.getElementById('downloadScan')?.addEventListener('click', ()=>{
      const values = getValues();
      const best = computeBest();
      const data = {
        timestamp: new Date().toISOString(),
        sliders: values,
        suggestion: best,
        practice: regions[best]?.practice || '',
        url: window.location.href
      };
      download(`neuro-scan-${timestamp()}.json`, JSON.stringify(data, null, 2));
    });

    document.getElementById('shareState')?.addEventListener('click', ()=>{
      const values = getValues();
      const best = computeBest();
      const title = regions[best]?.title || best;
      const parts = [`Self-Scan → focus: ${title}`, `Mood ${values.mood}`, `Memory ${values.mem}`, `Attention ${values.focus}`, `Stress ${values.stress}`, `Creativity ${values.create}`];
      const text = `I just mapped my mind on NeuroMap. ${parts.join(' · ')} #NeuroMap #BrainMap`;
      const intent = 'https://twitter.com/intent/tweet?text=' + encodeURIComponent(text) + '&url=' + encodeURIComponent(window.location.href);
      window.open(intent, '_blank','noopener');
    });

    // ===== Reveal on scroll =====
    (function reveal(){
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)');
      if(reduce.matches) return;
      const obs = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if(entry.isIntersecting){
            entry.target.classList.add('show');
            obs.unobserve(entry.target);
          }
        });
      }, {threshold:.12, rootMargin:'0px 0px -40px 0px'});
      $$('.reveal').forEach(el=> obs.observe(el));
    })();

    // ===== Magnetic buttons =====
    (function magnets(){
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)');
      if(reduce.matches) return;
      $$('.btn').forEach(btn=>{
        const strength = 18;
        function move(e){
          const r = btn.getBoundingClientRect();
          const mx = e.clientX - (r.left + r.width/2);
          const my = e.clientY - (r.top + r.height/2);
          btn.style.setProperty('--tx', (mx/r.width*strength)+'px');
          btn.style.setProperty('--ty', (my/r.height*strength)+'px');
          btn.classList.add('magnet-hover');
        }
        function leave(){
          btn.classList.remove('magnet-hover');
          btn.style.removeProperty('--tx');
          btn.style.removeProperty('--ty');
        }
        btn.addEventListener('mousemove', move);
        btn.addEventListener('mouseleave', leave);
      });
    })();

    // ===== Cursor orb =====
    (function cursorOrb(){
      const orb = document.getElementById('cursorOrb');
      if(!orb) return;
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)');
      if(reduce.matches) return;
      let tx=0, ty=0, cx=0, cy=0, hide=0;
      function onMove(e){
        tx = e.clientX;
        ty = e.clientY;
        document.body.classList.add('interacting');
        clearTimeout(hide);
        hide = setTimeout(()=> document.body.classList.remove('interacting'), 800);
      }
      window.addEventListener('mousemove', onMove, {passive:true});
      function raf(){
        cx += (tx - cx) * 0.12;
        cy += (ty - cy) * 0.12;
        orb.style.transform = `translate(${cx-120}px, ${cy-120}px)`;
        requestAnimationFrame(raf);
      }
      raf();
    })();

    // ===== Brainbox tilt =====
    (function tilt(){
      const box = document.querySelector('.brainbox');
      if(!box) return;
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)');
      if(reduce.matches) return;
      function move(e){
        const r = box.getBoundingClientRect();
        const x = (e.clientX - r.left)/r.width - .5;
        const y = (e.clientY - r.top)/r.height - .5;
        box.style.setProperty('--rx', (-y*6).toFixed(2)+'deg');
        box.style.setProperty('--ry', (x*8).toFixed(2)+'deg');
      }
      function leave(){
        box.style.removeProperty('--rx');
        box.style.removeProperty('--ry');
      }
      box.addEventListener('mousemove', move);
      box.addEventListener('mouseleave', leave);
    })();

    // ===== Tooltip =====
    (function tooltips(){
      const tip = document.getElementById('tip');
      function show(html,x,y){ tip.innerHTML = html; tip.hidden = false; tip.style.left = (x+14)+'px'; tip.style.top = (y+14)+'px'; }
      function hide(){ tip.hidden = true; }
      $$('#nodes .node').forEach(el=>{
        const id = el.getAttribute('data-id'); const n = atlas.nodes[id];
        el.addEventListener('mousemove', (e)=> show(`<strong>${n.name}</strong><br>${n.lobe} · ${n.networks.join(', ')}<br><span style='color:var(--muted)'>${n.desc}</span>`, e.clientX, e.clientY));
        el.addEventListener('mouseleave', hide);
        el.addEventListener('focus', ()=>{ const r = el.getBoundingClientRect(); show(`<strong>${n.name}</strong><br>${n.lobe} · ${n.networks.join(', ')}<br><span style='color:var(--muted)'>${n.desc}</span>`, r.left + r.width/2, r.top); });
        el.addEventListener('blur', hide);
      });
      window.addEventListener('scroll', ()=> tip.hidden=true, {passive:true});
    })();

    // ===== Networks filter & lobes toggle =====
    const netChecks = {
      Exec: document.getElementById('netExec'),
      Salience: document.getElementById('netSalience'),
      Default: document.getElementById('netDefault'),
      Lang: document.getElementById('netLang'),
      Sensor: document.getElementById('netSensor'),
      Visual: document.getElementById('netVisual'),
      Auditory: document.getElementById('netAuditory')
    };
    const netFilters = { Exec:true, Salience:true, Default:true, Lang:true, Sensor:true, Visual:true, Auditory:true };
    function networkKey(net){
      return net==='Executive Control'? 'Exec'
        : net==='Default Mode'? 'Default'
        : net==='Language'? 'Lang'
        : net==='Sensorimotor'? 'Sensor'
        : net; // Salience/Visual/Auditory
    }
    function updateNetworkVisibility(){
      $$('#nodes .node').forEach(el=>{
        const id = el.getAttribute('data-id');
        const node = atlas.nodes[id];
        const key = networkKey(node.networks[0] || 'Executive Control');
        const visible = netFilters[key] !== false;
        el.style.display = visible ? '' : 'none';
        if(!visible && currentNode === id){ currentNode = null; tryBtn.disabled = !currentRegion; }
      });
    }
    Object.entries(netChecks).forEach(([key, el])=>{
      el?.addEventListener('change', ()=>{ netFilters[key] = el.checked; updateNetworkVisibility(); });
    });

    async function loadAtlas(){
      try{
        const res = await fetch('atlas.json', {cache:'no-store'});
        if(!res.ok) return;
        const data = await res.json();
        if(data.nodes){ atlas.nodes = Object.assign(atlas.nodes, data.nodes); }
        if(data.networks){ atlas.networks = Object.assign(atlas.networks, data.networks); }
        if(data.feelings){ atlas.feelings = Object.assign(atlas.feelings, data.feelings); }
        if(data.bib){ Object.assign(bib, data.bib); }
        if(data.refsByNode){ nodeRefs = Object.assign({}, nodeRefs, data.refsByNode); }
        if(data.refsByCategory){ categoryRefs = Object.assign({}, categoryRefs, data.refsByCategory); }
        rebuildNodes();
      }catch(e){ /* silent */ }
    }

    document.getElementById('toggleLobes')?.addEventListener('change', (e)=>{
      document.getElementById('lobes').classList.toggle('hidden', !e.target.checked);
    });
    updateNetworkVisibility();
    loadAtlas();

    function setHemisphere(side){
      currentHemisphere = side;
      const brain = document.getElementById('brain');
      const lobes = document.getElementById('lobes');
      const regionsGroup = document.getElementById('regions');
      const transform = side==='R' ? 'translate(800,0) scale(-1,1)' : '';
      brain.setAttribute('transform', transform);
      lobes.setAttribute('transform', transform);
      regionsGroup.setAttribute('transform', transform);
      Object.entries(atlas.nodes).forEach(([id, node])=>{
        const x = side==='R' ? (800 - node.x0) : node.x0;
        const y = node.y0;
        node.x = x; node.y = y;
        const el = document.querySelector(`#nodes .node[data-id="${id}"]`);
        if(!el) return;
        const circle = el.querySelector('circle');
        const text = el.querySelector('text');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        text.setAttribute('x', x + (side==='R'? -10:10));
        text.setAttribute('y', y + 4);
        text.setAttribute('text-anchor', side==='R'? 'end' : 'start');
      });
      if(activePathSequence){
        drawPath(activePathSequence);
      } else {
        drawPath(null);
      }
    }
    document.getElementById('hemi')?.addEventListener('change', e=> setHemisphere(e.target.value));

    let setHotspots = ()=>{};

    // ===== Neuron canvas =====
    (function neuronsScene(){
      const box = document.querySelector('.brainbox');
      const svg = box?.querySelector('svg');
      const pathEl = svg?.querySelector('#brainSilhouette');
      const canvas = document.getElementById('neuronsCanvas');
      if(!box || !svg || !pathEl || !canvas) return;
      const ctx = canvas.getContext('2d');
      let W=0, H=0, dpr=Math.min(2, window.devicePixelRatio||1);
      const vb = svg.viewBox.baseVal;
      const silhouette = new Path2D(pathEl.getAttribute('d'));
      let zoom=1, ox=0, oy=0, panning=false, px=0, py=0;

      function applyTransform(){
        const transform = `translate(${ox}px, ${oy}px) scale(${zoom})`;
        svg.style.transformOrigin = '0 0';
        canvas.style.transformOrigin = '0 0';
        svg.style.transform = transform;
        canvas.style.transform = transform;
      }

      box.addEventListener('wheel', (e)=>{
        if(!(e.ctrlKey || e.altKey)) return;
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        const rect = box.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        ox = mx - (mx - ox)*factor;
        oy = my - (my - oy)*factor;
        zoom *= factor;
        applyTransform();
      }, {passive:false});

      box.addEventListener('mousedown', (e)=>{ panning=true; px=e.clientX; py=e.clientY; });
      window.addEventListener('mouseup', ()=>{ panning=false; });
      window.addEventListener('mousemove', (e)=>{
        if(!panning) return;
        ox += e.clientX - px;
        oy += e.clientY - py;
        px = e.clientX; py = e.clientY;
        applyTransform();
      });

      // Touch gestures: 1-finger pan, 2-finger pinch zoom
      let tStartDist=0, tStartOx=0, tStartOy=0, tStartZoom=1, tStartCx=0, tStartCy=0;
      function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
      function center(a,b){ return {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2}; }

      box.addEventListener('touchstart', (e)=>{
        if(e.touches.length===1){ panning=true; px=e.touches[0].clientX; py=e.touches[0].clientY; }
        if(e.touches.length===2){
          e.preventDefault();
          const c=center(e.touches[0], e.touches[1]);
          const r = box.getBoundingClientRect();
          tStartCx=c.x - r.left; tStartCy=c.y - r.top;
          tStartDist=dist(e.touches[0], e.touches[1]);
          tStartOx=ox; tStartOy=oy; tStartZoom=zoom;
        }
      }, {passive:false});

      box.addEventListener('touchmove', (e)=>{
        if(e.touches.length===1 && panning){
          e.preventDefault();
          ox += (e.touches[0].clientX - px);
          oy += (e.touches[0].clientY - py);
          px=e.touches[0].clientX; py=e.touches[0].clientY;
          applyTransform();
        }
        if(e.touches.length===2){
          e.preventDefault();
          const d=dist(e.touches[0], e.touches[1]); const k=d/tStartDist;
          zoom = Math.max(0.5, Math.min(3, tStartZoom * k));
          ox = tStartCx - (tStartCx - tStartOx) * k;
          oy = tStartCy - (tStartCy - tStartOy) * k;
          applyTransform();
        }
      }, {passive:false});

      box.addEventListener('touchend', ()=>{ panning=false; }, {passive:true});

      document.getElementById('zoomIn')?.addEventListener('click', ()=>{ zoom*=1.1; applyTransform(); });
      document.getElementById('zoomOut')?.addEventListener('click', ()=>{ zoom*=0.9; applyTransform(); });
      document.getElementById('zoomReset')?.addEventListener('click', ()=>{ zoom=1; ox=0; oy=0; applyTransform(); });

      let neurons=[]; let N=120; let sx=1, sy=1; let grid={}; const GRID=60;
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      function resize(){
        const rect = canvas.getBoundingClientRect();
        W = canvas.clientWidth; H = canvas.clientHeight;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        sx = W / vb.width;
        sy = H / vb.height;
        N = Math.max(60, Math.min(160, Math.round((W*H)/(isCoarse? 18000 : 12000))));
        if(neurons.length < N){ for(let i=neurons.length;i<N;i++) neurons.push(spawnNeuron()); }
        if(neurons.length > N){ neurons.length = N; }
      }

      function inBrain(u,v){
        ctx.save();
        ctx.scale(sx, sy);
        const inside = ctx.isPointInPath(silhouette, u, v);
        ctx.restore();
        return inside;
      }

      function spawnNeuron(){
        let u,v;
        do{
          u = Math.random()*vb.width;
          v = Math.random()*vb.height;
        }while(!inBrain(u,v));
        const theta = Math.random()*Math.PI*2;
        const uvx = Math.cos(theta)*(0.2+Math.random()*0.6);
        const uvy = Math.sin(theta)*(0.2+Math.random()*0.6);
        const branch = (len=3)=>Array.from({length:len},()=>({dx:(Math.random()*20-10), dy:(Math.random()*20-10)}));
        return { u,v, uvx, uvy, fire:Math.random()*2000, branch:branch(2+Math.floor(Math.random()*2)), glow:0 };
      }

      function update(dt){
        grid = {};
        for(const n of neurons){
          n.u += n.uvx * dt * 0.06;
          n.v += n.uvy * dt * 0.06;
          if(!inBrain(n.u,n.v)){
            n.uvx *= -1; n.uvy *= -1;
            n.u += n.uvx * dt * 0.12;
            n.v += n.uvy * dt * 0.12;
          }
          n.fire -= dt;
          if(n.fire <= 0){ n.fire = 1500 + Math.random()*2500; n.glow = 1; }
          n.glow *= 0.96;
          const gx = Math.floor((n.u*sx)/GRID);
          const gy = Math.floor((n.v*sy)/GRID);
          const key = `${gx},${gy}`;
          (grid[key] ||= []).push(n);
        }
      }

      function neighbors(n){
        const gx = Math.floor((n.u*sx)/GRID);
        const gy = Math.floor((n.v*sy)/GRID);
        const out=[];
        for(let i=-1;i<=1;i++){
          for(let j=-1;j<=1;j++){
            const cell = grid[`${gx+i},${gy+j}`];
            if(cell) out.push(...cell);
          }
        }
        return out;
      }

      let hotspots=[];
      setHotspots = function(list){
        hotspots = (list || []).map(id=>atlas.nodes[id]).filter(Boolean);
      };

      function biasHotspots(){
        if(!hotspots.length) return;
        for(const n of neurons){
          let minD = Infinity;
          for(const h of hotspots){
            const dx = (h.x*sx) - (n.u*sx);
            const dy = (h.y*sy) - (n.v*sy);
            const d = Math.hypot(dx,dy);
            if(d < minD) minD = d;
          }
          if(minD < 90){
            n.glow = Math.max(n.glow, (90-minD)/90);
            if(Math.random()<0.02) n.fire = 0;
          }
        }
      }

      function draw(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();
        ctx.scale(sx, sy);
        for(const n of neurons){
          const near = neighbors(n);
          for(const m of near){
            if(m===n) continue;
            const dx = m.u - n.u;
            const dy = m.v - n.v;
            const dist = Math.hypot(dx,dy);
            if(dist < 60){
              ctx.globalAlpha = 0.06 * (1 - dist/60) * (0.3 + 0.7*Math.max(n.glow, m.glow));
              ctx.beginPath();
              ctx.moveTo(n.u, n.v);
              ctx.lineTo(n.u + dx*0.6, n.v + dy*0.6);
              ctx.strokeStyle='rgba(122,162,255,1)';
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }
        ctx.globalAlpha = 1;
        for(const n of neurons){
          ctx.beginPath();
          ctx.arc(n.u, n.v, (2.2 + n.glow*1.6), 0, Math.PI*2);
          ctx.fillStyle = `rgba(245,208,111,${0.5+0.5*n.glow})`;
          ctx.fill();
          ctx.beginPath();
          for(const b of n.branch){
            ctx.moveTo(n.u, n.v);
            ctx.lineTo(n.u + b.dx*0.6, n.v + b.dy*0.6);
          }
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.stroke();
        }
        ctx.restore();
      }

      let last = performance.now();
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)');
      function frame(now){
        const dt = Math.min(50, now - last);
        last = now;
        update(dt);
        biasHotspots();
        draw();
        if(!reduce.matches) requestAnimationFrame(frame);
      }

      window.addEventListener('resize', resize);
      resize();
      if(!reduce.matches) requestAnimationFrame(frame);
      applyTransform();
    })();

    setHemisphere('L');
  </script>
</body>
</html>
